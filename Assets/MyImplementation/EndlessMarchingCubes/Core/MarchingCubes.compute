#pragma kernel MarchingCubes
#include "./MarchingCubesTable.compute"
static const int numThreads = 8;

struct Triangle{
    float3 v0;
    float3 v1;
    float3 v2;
};
RWStructuredBuffer<float4> pointsBuffer;
AppendStructuredBuffer<Triangle> triangleBuffer;

int numPointsPerAxis;
int indexFromCoord(int3 coord){
    return coord.z * numPointsPerAxis * numPointsPerAxis + coord.y * numPointsPerAxis + coord.x;
}

float isoLevel;
float3 InterpolateVerts(float4 v1, float4 v2){
    float t = (isoLevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz - v1.xyz);
}

[numthreads(numThreads,numThreads,numThreads)]
void MarchingCubes (uint3 id : SV_DispatchThreadID)
{
    if(id.x>=numPointsPerAxis-1 || id.y>=numPointsPerAxis-1 || id.z>=numPointsPerAxis-1){
        return;
    }
    float4 cubeCorners[8] = 
    {
        pointsBuffer[indexFromCoord(int3(id.x,id.y,id.z))],
        pointsBuffer[indexFromCoord(int3(id.x+1,id.y,id.z))],
        pointsBuffer[indexFromCoord(int3(id.x+1,id.y,id.z+1))],
        pointsBuffer[indexFromCoord(int3(id.x,id.y,id.z+1))],
        pointsBuffer[indexFromCoord(int3(id.x,id.y+1,id.z))],
        pointsBuffer[indexFromCoord(int3(id.x+1,id.y+1,id.z))],
        pointsBuffer[indexFromCoord(int3(id.x+1,id.y+1,id.z+1))],
        pointsBuffer[indexFromCoord(int3(id.x,id.y+1,id.z+1))]
    };
    int cubeIndex = 0;
    if(cubeCorners[0].w>=isoLevel)cubeIndex|=1;
    if(cubeCorners[1].w>=isoLevel)cubeIndex|=2;
    if(cubeCorners[2].w>=isoLevel)cubeIndex|=4;
    if(cubeCorners[3].w>=isoLevel)cubeIndex|=8;
    if(cubeCorners[4].w>=isoLevel)cubeIndex|=16;
    if(cubeCorners[5].w>=isoLevel)cubeIndex|=32;
    if(cubeCorners[6].w>=isoLevel)cubeIndex|=64;
    if(cubeCorners[7].w>=isoLevel)cubeIndex|=128;
    // 查表输出三角形
    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3) {
        int a0 = cornerIndexAFromEdge[triangulation[cubeIndex][i]];
        int b0 = cornerIndexBFromEdge[triangulation[cubeIndex][i]];
        
        int a1 = cornerIndexAFromEdge[triangulation[cubeIndex][i+1]];
        int b1 = cornerIndexBFromEdge[triangulation[cubeIndex][i+1]];
        
        int a2 = cornerIndexAFromEdge[triangulation[cubeIndex][i+2]];
        int b2 = cornerIndexBFromEdge[triangulation[cubeIndex][i+2]];
        
        Triangle tri;
        tri.v0 = InterpolateVerts(cubeCorners[a0], cubeCorners[b0]);
        tri.v1 = InterpolateVerts(cubeCorners[a1], cubeCorners[b1]);
        tri.v2 = InterpolateVerts(cubeCorners[a2], cubeCorners[b2]);
        
        triangleBuffer.Append(tri);
    }
}



